#КОНТРОЛНА РАБОТА № 1 ПО ФУНКЦИОНАЛНО ПРОГРАМИРАНЕ
Специалност “Компютърни науки”, 2-ри курс, 1-ви поток
28.11.2015 г.
Вариант 1

###[Задача 1.](prep1-v1-1zad.rkt)​
Да се дефинира функция (sum-sum-digit a b k), която намира сумата на естествените
числа от a до b (0<a≤b), сумата от цифрите на които е кратна на k.

###[Задача 2.](prep1-v1-2zad.rkt)​
​Да се дефинира функция (max-ordered-sublist lst), която намира най-дългия възходящо
сортиран подсписък на списъка от числа lst.
Пример: (max-ordered-sublist ‘(1 5 2 4 6 8 3 4 1)) → ‘(2 4 6 8)

###[Задача 3.](prep1-v1-3zad.rkt)​
Да се дефинира предикат (triangular? mat), който получава квадратна числова матрица,
представена като списък от списъци, и проверява дали тя е горно триъгълна, т.е. дали всичките
елементи под главния й диагонал са нули.
Пример 1: (triangular? ‘((1 2 3) (0 5 6) (0 0 9))) → #t
Пример 2: (triangular? ‘((0 2 3) (0 0 6) (1 0 0))) → #f

###[Задача 4.](prep1-v1-4zad.rkt)​
​Да се дефинира функция (pair-compose fs), която получава списък
(f1 f2 f3 ... fn) от едноаргументни числови функции и връща нова едноаргументна числова
функция g - такава, че оценката на (g x) е равна на сумата
(f1 . f2) (x) + (f3 . f4) (x) + ... + (fn-1 . fn) (x), където “.” означава композиция на функции.
Ако оригиналният списък с функции има нечетен брой елементи, то последната функция от
списъка се композира с функцията идентитет, която получава един аргумент и го връща без
промяна.
Пример:
(define g (pair-compose (list add1 add2)))
(g 1) → (add1 . add2) (1) → 4

###[Задача 5.](prep1-v1-5zad.rkt)​
Да се дефинира функция (all-sums lst), която получава списък lst от не повече от 10
цели неотрицателни числа и връща нов списък, съдържащ сумите на числата във всички
възможни непразни подмножества на lst, но без повторения и в какъвто и да е ред.
Пример 1: Нека имаме списък с числата 1, 2, 3. Всички възможни суми за подмножества са: 1 = 1,
2 = 2, 3 = 1+2 = 3, 4 = 1+3, 5 = 2+3 и 6 = 1+2+3.
Пример 2: Нека имаме списък с числата 0, 1, 2. Всички възможни суми за подмножества са: 0 = 0,
1 = 1 = 0+1, 2 = 2 = 0+2, 3 = 1+2 = 0+1+2.
(all-sums (list 1 2 3)) → ‘(1 2 3 4 5 6)
(all-sums (list 0 1 2)) → ‘(0 1 2 3)
Забележка: Отговор ‘(2 1 0 3) също е коректен, но не и ‘(0 1 1 2 2 3 3)).

#КОНТРОЛНА РАБОТА № 1 ПО ФУНКЦИОНАЛНО ПРОГРАМИРАНЕ
Специалност “Компютърни науки”, 2-ри курс, 1-ви поток
28.11.2015 г.
Вариант 2

###Задача 1.​
Да се дефинира функция (prod-sum-div a b k), която намира произведението на
естествените числа от a до b (0<a≤b), сумата от делителите на които е кратна на k.

###Задача 2.
​Да се дефинира функция (max-eq-subseq lst), която намира най-дългия подсписък на
списъка lst, съставен от еднакви елементи на lst.
Пример 1: (max-eq-subseq ‘(1 2 3 3 4 4 4 5 6 6) → ‘(4 4 4)
Пример 2: (max-eq-subseq ‘(1 2 2 3 4 4 5 6 6) → ‘(2 2) или ‘(4 4) или ‘(6 6)

###Задача 3.
​Да се дефинира предикат (triangular? mat), който получава квадратна числова матрица,
представена като списък от списъци, и проверява дали тя е долно триъгълна, т.е. дали всичките
елементи над главния й диагонал са нули.
Пример 1: (triangular? ‘((1 0 0) (4 5 0) (7 8 9))) → #t
Пример 2: (triangular? ‘((0 0 1) (4 0 0) (7 0 0))) → #f

###Задача 4.​
Да се дефинира функция (list-compose fs1 fs2), която получава два списъка
(f1 f2 f3 ... fn) и (g1 g2 … gm) от едноаргументни числови функции и връща нова едноаргументна
числова функция h - такава, че оценката на (h x) е равна на сумата
(f1 . g1) (x) + (f2 . g2) (x) + ... + (fk . gk) (x), където “.” означава композиция на функции, а k е
по-голямото от числата n и m. Ако n≠m, по-късият списък от функции се допълва с необходимия
брой елементи, съвпадащи с функцията идентитет, която получава един аргумент и го връща
без промяна.
Пример:
(define h (list-compose (list add1 add2) (list add1 add2)))
(h 1) → (add1 . add1) (1) + (add2 . add2) (1) → 3 + 5 → 8

###Задача 5.
​Да се дефинира функция (all-prods lst), която получава списък lst от не повече от 10
цели неотрицателни числа и връща нов списък, съдържащ произведенията на числата във всички
възможни непразни подмножества на lst, но без повторения и в какъвто и да е ред.
Пример 1: Нека имаме списък с числата 1, 2, 3. Всички възможни произведения за подмножества
са: 1 = 1, 2 = 2 = 2.1, 3 = 3 = 3.1, 6 = 2.3 = 1.2.3.
Пример 2: Нека имаме списък с числата 0, 1, 2. Всички възможни произведения за подмножества
са: 0 = 0 = 0.1 = 0.2 = 0.1.2, 1 = 1, 2 = 2 = 2.1.
(all-prod (list 1 2 3)) → ‘(1 2 3 6)
(all-prod (list 0 1 2)) → ‘(0 1 2)
Забележка: Отговор ‘(1 0 2) също е коректен, но не и ‘(0 0 0 0 1 2 2)).
