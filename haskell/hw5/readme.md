#Структура от данни **Treap**



###Съдържание:
1. Кратко описание на структурата **Treap**
2. Базов модул `Treap.hs`
3. Допълнение `TreapIO.hs`
4. Тестове на трийпа в `main.hs`


### 1. Кратко описание на структурата Treap

[Статия в Wikipedia](https://en.wikipedia.org/wiki/Treap)

Думата __Treap__ е комбинация от Heap и Tree, тъй като структурата представлява двоично дърво за търсене по ключове, в което за всеки връх се избира *произволен* приоритет, за който искаме изпълнени heap-свойства (тоест приоритета на всеки връх да е по-голям от приоритета на наследниците). Произволността ни дава сравнително равномерно разпределение при добавяне на нови върхове, тоест дървото остава сравнително балансирано и ни позволява търсене за логаритмично време.

Основните операции за трийп са: проверка дали е празен, търсене / добавяне / триене  на ключ.


### 2. Базов модул `Treap.hs`
	Този модул съдържа основната логика зад всяка от основните операции върху трийп. Съдържа само чисти (не IO) функции и следователно не използва произволни числа.

* Тип ключ, произволен тип (в някои функции се изисква той да е ??? на `Eq`, `Ord`, `Show`);
* Тип приоритет, цяло число;
* Тип елемент, наредена двойка от ключ и приоритет;
* Алгебричен тип трийп - празен трийп или трийп с корен елемент и ляв и десен наследник – трийпове;

* `empty :: Treap a → Bool`
Празен ли е трийп?
Според конструктора му
* `contains :: Treap a → Key a → Bool`
Съдържа ли трийпа дадения ключ?
Търсене като в двоично наредено дърво
* `addElement :: Treap a → Element a → Treap a`
Добавя елемент в трийпа
Според ключа му намира място като листо (като в двоично дърво за търсене) 
Според приоритета му извършва ротации, за да запази хийп-свойствата
Използват се функциите `fixLeftPriority` и `fixRightPriority` съответно за стандартни десни и леви ротации в двоично дърво
Връща нов трийп с вече добавен елемента
* `delete :: Treap a → Key a → Treap a`
Изтрива ключ от трийп
Търси ключа според правилата на двоично дърво за търсене
Разглеждат се отделнни случаи ако ключа се окаже листо / връх с един наследник / връх с два наследника
Използва вътрешните функции `leftMost`, `rightMost`, които приемат трийп и връщат съответно най-левия и най-десния му елемент.
* `toList :: Treap a → [a]`, `toString :: Treap a → String`
Приемат трийп и връща ‘ляво-корен-дясно’ обхождане на ключовете му в съответния формат
* `rotateToString :: Treap a → String`
Приема трийп и връща стринг, в който всеки ключ (или елемент) е на отделен ред и е индентиран според нивото си в трийпа
Може да включва или не символ за празен трийп
За всяко ниво в трийпа първо е лявото поддърво, после корена и накрая дясното
* `rotateToString` се използва за дефиниране на функцията `show` за трийп, за да може да се печата просто с print

### 3. Допълнение TreapIO.hs
	Този модул ни предоставя основната характеристика на трйпа – произволните приоритети. Това става с цената на това всички функции да бъдат IO и следователно да не могат да се използват в чисти функции.
	`TreapIO.hs` съдържа IO еквивалент на функциите от `Treap.hs` като в имената е добавен префикс ‘io’ с цел да няма нужда от `qualified import` при успоредно използване на двата модула. Предназначено е потребителите да импортират `Treap.hs` и `TreapIO.hs` заедно.
	Основната структура на фунцкиите в този модул е:
* приемане на IO обект
* разпакетиране / свързване на IO обекта с обикновен
* извикване на чиста Treap.hs функция с обикновения обект
* връщане на резултата пакетиран отново в IO обект

	Особеност има само при функцията `ioAdd` която освен вече избоените стъпки, взима (псевдо-)произволно число в итервала [1, 10 000] и го използва като приоритет при добавяне на ключа.

### 4. Тестове на трийпа в `main.hs`
	Използваме няколко примерни IO функции:
* `testTreapOfDifferentTypes`
Създава два трийпа с тип на ключовете `Int` и `Char` и ги принтира
Закоментиран е ред, в който се прави опит за добавяне на `Char` ключ към `Int` трийп, който би дал грешка при компилация
* `testTreapIO`
Извиква четирите основни трийп функции с примерни данни
* `compareSameVsRandomPriorities`
Създава `Treap` от ключове с еднакви приоритети и `ioTreap` с произволно избрани такива.
Принтира ги и демонстрира, че височината на `Treap` е линейна, а на `ioTreap` е логаритмична.
