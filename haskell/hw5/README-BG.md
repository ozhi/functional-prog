#Структура от данни **Treap**

###Съдържание:
1. Кратко описание на структурата Treap
2. Базов модул `Treap.hs`
3. Допълнение `TreapIO.hs`
4. Тестове в `main.hs`


### 1. Кратко описание на структурата Treap

[Статия в Wikipedia](https://en.wikipedia.org/wiki/Treap)
	
Думата Treap (трийп) е комбинация от Heap и Tree, тъй като структурата представлява двоично дърво за търсене по ключове, в което за всеки връх се избира *произволен* приоритет, за който искаме изпълнени heap-свойства (тоест приоритета на всеки връх да е по-голям от приоритета на наследниците). Произволността ни дава сравнително равномерно разпределение при добавяне на нови върхове, тоест дървото остава сравнително балансирано и ни позволява търсене за логаритмично време.

Основните операции за трийп са: проверка дали е празен, търсене / добавяне / триене  на ключ.


### 2. Базов модул Treap.hs

Този модул съдържа основната логика зад всяка от основните операции върху Treap. Съдържа само чисти (не IO) функции и следователно не използва произволни числа. Основни моменти в модула:

* Тип ключ, произволен тип (в някои функции се изисква той да е екземпляр на класовете `Eq`, `Ord`, `Show`)
* Тип приоритет, цяло число [1; 10 000]
* Тип елемент, наредена двойка от ключ и приоритет
* Алгебричен тип трийп - празен трийп или трийп с корен елемент и ляв и десен наследник – трийпове

* `empty :: Treap a → Bool` 

Празен ли е трийп?

Според конструктора му

* `contains :: Treap a → Key a → Bool`

Съдържа ли трийпа дадения ключ?

Търсене като в двоично наредено дърво

* `add :: Treap a → Element a → Treap a`

Добавя елемент в трийпа

Според ключа му намира място като листо (според алгоритъма за двоично дърво за търсене) 

Според приоритета му извършва ротации, за да възвърне хийп-свойствата

Използват се функциите `fixLeftPriority` и `fixRightPriority` съответно за стандартни десни и леви ротации в двоично дърво

Връща нов трийп с вече добавен елемента

* `delete :: Treap a → Key a → Treap a`

Изтрива ключ от трийп

Търси ключа според алгоритъма на двоично дърво за търсене

Разглеждат се отделнни случаи ако ключа се окаже листо / връх с един наследник / връх с два наследника

Използва вътрешните функции `leftMost`, `rightMost`, които приемат трийп и връщат съответно най-левия или най-десния му елемент

* `toList :: Treap a → [a]`

`toString :: Treap a → String`

Приемат трийп и връщат ‘ляво-корен-дясно’ обхождане на ключовете му в съответния формат

* `rotateToString :: Treap a → Int → Bool → Bool → String`

Приема трийп и няколко опции, връща стринг, представляващ визуализация на структурата на трийпа

Всеки ключ е на отделен ред и е индентиран според дълбочината си в трийпа

Подредбата е ляво-корен-дясно

* `rotateToString` се използва за дефиниране на функцията `show` за трийп, за да може да се печата просто с `print`


### 3. Допълнение TreapIO.hs

Този модул ни предоставя основната характеристика на трйпа – произволните приоритети. Това става с цената на това всички функции да бъдат IO и следователно да не могат да се използват в чисти функции.

`TreapIO.hs` съдържа IO еквиваленти на функциите от `Treap.hs` като в имената е добавен префикс ‘io’ с цел да няма нужда от `qualified import` при успоредно използване на двата модула. Предназначено е потребителите да импортират и използват `Treap.hs` и `TreapIO.hs` заедно.

Основната структура на фунцкиите в този модул е:

* приемане на IO обект
* разпакетиране / свързване на IO обекта с обикновен
* подаване на обикновения обект на съответната чиста функция от `Treap.hs`
* връщане на резултата пакетиран отново в IO обект

Особеност има само при функцията `add`, която освен вече избоеното взима (псевдо-)произволно число в итервала [1, 10 000] с помощта на `System.Random` и го използва като приоритет при добавяне на ключа.

### 4. Тестове в main.hs

* `testTreapOfDifferentTypes`

Създава два трийпа с тип на ключовете `Int` и `Char` и ги принтира

Закоментиран е ред, в който се прави опит за добавяне на `Char` ключ към `Int` трийп, който би дал грешка при компилация

* `testPrintRepresentations`

Създава примерен ioTreap и го принтира като стринг и като списък

* `testTreapIO`
Извиква четирите основни трийп функции с примерни данни

* `compareSameVsRandomPriorities`

Създава Treap от ключове с еднакви приоритети и ioTreap с произволно избрани такива.

Принтира ги и демонстрира, че височината на Treap е линейна, а на ioTreap е логаритмична.

